2.4のMIPS命令の数を最小にするようにアセンブリコードを書き直せ。

sll  $t0, $s0, 2   # $t0 = f * 4
add  $t0, $s6, $t0 # $t0 = &A[f]
sll  $t1, $s2, 2   # $t1 = h * 4
add  $t1, $s7, $t1 # $t1 = &B[h]
lw   $s0, 0($t0)   # f = A[f]
addi $t2, $t0, 4   # $t2 = A[f+1] バイトアドレスからワードアドレスへ変換するから4->1
lw   $t0, 0($t2)   # $t0 = A[f+1]
add  $t0, $t0, $s0 # $to = A[f+1] + A[f]
sw   $t0, 0($t1)

変数f, g, h, i, j
レジスタ $s0, $s1, $s2, $s3, $s4
配列A, 配列Bのベースレジスタ -> $s6, $s7

--


2bit左シフトすると4倍
(001)2 = 1
(100)2 = 4

MIPSアーキテクチャでは1ワード32bitなのでアセンブリのメモリアドレスに関係するオペランドの実際のアドレス値は1/4になることに注意

--

addiのオフセットの演算を消してlwで意図したアドレスを読み込むためにオフセットを変更した

sll  $t0, $s0, 2   # $t0 = f * 4
add  $t0, $s6, $t0 # $t0 = &A[f]
sll  $t1, $s2, 2   # $t1 = h * 4
add  $t1, $s7, $t1 # $t1 = &B[h]
lw   $s0, 0($t0)   # f = A[f]
lw   $t0, 4($t2)   # $t0 = A[f+1]
add  $t0, $t0, $s0 # $to = A[f+1] + A[f]
sw   $t0, 0($t1)
